{"timestamp": 1769614269.333928, "stored_source_code": "# declare a list tasks whose products you want to use as inputs\nupstream = None\n\n%pip install duckdb pandas numpy matplotlib requests python-dotenv jupysql duckdb-engine scikit-learn fastapi\n\n# EDA for Content Based Recommendation System\nimport os\nimport duckdb\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# DuckDB database path:\n# - In the Docker/Ploomber pipeline this file is created by the 'extract' task.\n# - You can override it via env var DUCKDB_PATH.\n_default_db = \"movie_rec_system/movies_data.duckdb\"\n_fallback_db = \"movies_data.duckdb\"\nDB_PATH = os.getenv(\"DUCKDB_PATH\", _default_db if os.path.exists(_default_db) else _fallback_db)\n\ncon = duckdb.connect(DB_PATH)\n\ndef q(sql: str) -> pd.DataFrame:\n    \"\"\"Run a SELECT query and return a pandas DataFrame.\"\"\"\n    return con.sql(sql).df()\n\n# Inspect schema\nq(\"DESCRIBE movies\")\nq(\"DESCRIBE genres\")\n# Preview data\nq(\"SELECT * FROM movies LIMIT 5\")\nq(\"SELECT * FROM genres LIMIT 5\")\nmovie_genres = q(\"\"\"\nWITH ExpandedGenres AS (\n    SELECT \n        m.id AS movie_id,\n        mg.movie_genre_id,\n        g.name AS genre_name\n    FROM \n        (SELECT UNNEST(movies.genre_ids) AS movie_genre_id, movies.id FROM movies) AS mg\n    JOIN movies m ON mg.id = m.id\n    JOIN genres g ON mg.movie_genre_id = g.id\n)\nSELECT\n    movie_id,\n    STRING_AGG(genre_name, ', ') AS genre_names\nFROM ExpandedGenres\nGROUP BY movie_id;\n\"\"\")\nmovie_genres.head()\n## Expanded genres per movie\n\n(Computed above as `movie_genres`.)\nMovies with 0 vote_counts are usually unreleased. Filtering this out allows for recommendations for only available movies.\n# Materialize a helper table used for EDA plots\ncon.execute(\"\"\"CREATE TABLE IF NOT EXISTS movie_genre_data AS\nWITH ExpandedGenres AS (\n    SELECT \n        m.id AS movie_id,\n        mg.movie_genre_id,\n        g.name AS genre_name\n    FROM \n        (SELECT UNNEST(movies.genre_ids) as movie_genre_id, movies.id FROM movies) AS mg\n    JOIN \n        movies m ON mg.id = m.id\n    JOIN \n        genres g ON mg.movie_genre_id = g.id\n),\ngenre_names AS (\n    SELECT\n    movie_id,\n    STRING_AGG(genre_name, ', ') AS genre_names\nFROM \n    ExpandedGenres\nGROUP BY \n    movie_id\n)\nSELECT gn.genre_names, m.id, m.original_language,\n       m.overview, m.popularity, m.release_date,\n       m.title, m.vote_average, m.vote_count\nFROM genre_names gn\nJOIN movies m\nON gn.movie_id = m.id\nWHERE m.vote_count != 0\"\"\")\nq(\"SELECT COUNT(*) AS n_rows FROM movie_genre_data\")\ndf = q(\"SELECT * FROM movie_genre_data\")\ndf.head()\n# plt.figure(figsize=(10,4))\n# plt.hist(df[\"popularity\"].dropna(), bins=20)\n# plt.grid(True)\n# plt.title(\"Movie Popularity\")\n# plt.xlabel(\"Popularity\")\n# plt.ylabel(\"Count\")\n# plt.tight_layout()\n# plt.show()\n# plt.figure(figsize=(10,4))\n# plt.hist(df[\"vote_average\"].dropna(), bins=20)\n# plt.grid(True)\n# plt.title(\"Vote Average\")\n# plt.xlabel(\"Vote Score\")\n# plt.ylabel(\"Count\")\n# plt.tight_layout()\n# plt.show()\n# plt.figure(figsize=(10,4))\n# plt.hist(df[\"vote_count\"].dropna(), bins=20)\n# plt.grid(True)\n# plt.title(\"Movie Vote Count\")\n# plt.xlabel(\"Votes\")\n# plt.ylabel(\"Count\")\n# plt.tight_layout()\n# plt.show()\ndf[\"release_date\"] = pd.to_datetime(df[\"release_date\"])\n\ndf[\"release_year\"] = df[\"release_date\"].dt.year\n\nmovie_counts_by_year = df.groupby(\"release_year\").size()\n\n# plt.figure(figsize=(10, 6))\n# plt.plot(movie_counts_by_year.index, movie_counts_by_year.values, marker=\"o\")\n# plt.xlabel(\"Release Year\")\n# plt.ylabel(\"Number of Movies Released\")\n# plt.title(\"Number of Movies Released Per Year\")\n# plt.tight_layout()\n# plt.grid()\n# plt.show()\ndf[\"genre_names\"] = df[\"genre_names\"].astype(str)\n\n\ndef get_genre_count(df):\n    genre_counts = dict()\n\n    for genres in df[\"genre_names\"]:\n        genre_list = genres.split(\",\")\n        for genre in genre_list:\n            if genre not in genre_counts:\n                genre_counts[genre] = 1\n            genre_counts[genre] += 1\n    return genre_counts\n\n\ngenre_counts = get_genre_count(df)\n\nsorted_genre_counts = dict(\n    sorted(genre_counts.items(), key=lambda item: item[1], reverse=True)\n)\n\ngenres = list(sorted_genre_counts.keys())\ncounts = list(sorted_genre_counts.values())\n\n# plt.figure(figsize=(16, 7))\n# plt.bar(genres, counts)\n# plt.ylabel(\"Genres\")\n# plt.xlabel(\"Counts\")\n# plt.title(\"Genre Counts\")\n# plt.tight_layout()\n# plt.xticks(rotation=60, ha=\"right\")\n# plt.grid()\n# plt.show()\n# Moving forward\n\nNow that preliminary data wrangling and EDA has been accomplished, the next step would be to implement a content based recommendation system. \n\nWe'll experiment using cosine TF-IDF on our movie's description and genres.", "params": {}}